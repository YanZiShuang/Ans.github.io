<html>
  <head>
    <!-- website title-->
<!--    <title>LilySu's Blog </title> -->
    <!-- icon-->

    <link rel="icon" type="image/x-icon" href="../images/favicon.ico"/>
    <meta charset="utf-8"/>
    <link rel='stylesheet' type='text/css' href='../css/custom.css'>
  </head>
  <body>
    <h1>CVE-2018-8453 从BSOD到ExpLoit</h1>
    <div id="toc_container">
      <p class="toc_title">
	contents
      </p>
      <li>
      <center><a href="#0x00">环境设置</a></center>
      </li>
      <li>
	<center><a href="#0x01">漏洞分析</a></center>
      </li>
      <li>
      <center><a href="#Download">附件下载</a></center>
      </li>
      </div>

    <h2 id="0x00"> 0x00: Windows10 1703 X64 无补丁</h2>
    <p>
      <img src="./img/systeminfo.png" width="800px">
    </p>

    <h2 id="0x01"> 0x01: 漏洞细节分析 </h2>
    <p>
      如何构造一个触发<font color="#82AAFF">BSOD</font>的Poc呢,根据网上现存的分析报告我们得到了一个这样触发<font color="#82AAFF">BSOD</font>的思路.
    </p>
    <ol>
      <li>
	创建两个窗口,一个父窗口,一个滚动条子控件
      </li>
      <li>
        Hook <code>PEB->KernelCallbackTable</code>中的<code>fnDword()</code>,<code>xxxClientAllocWindowClassExtraBytes()</code>函数指针的指向,让其指向我们自定义的处理函数.
      </li>
      <li>
	在<code>fnDword()</code>函数内释放父类窗口
      </li>
      <li>
	在<code>xxxClientAllocWindowClassExtraBytes()</code>函数内调用<code>NtUserSetWindowFNID()</code>函数,并创建新的滚动条控件,使用<code>SetCapture()</code>函数修改滚动条捕获窗口
      </li>
      <li>
	在<code>fnDword()</code> 函数内判断发送的<font class="Struct">Message</font>是否为<code>0x70</code>,如果是,则向新创建的滚动条控件发送<code>0x1F</code>号消息
      </li>
      <li>
	向 滚动条子控件(Scroll)发送<font class="Struct">WM_LBUTTONDOWN</font>消息即可触发BSOD
      </li>
    </ol>
    <p>
      虽然这样确实可以触发<font color="#82AAFF">BSOD</font>,但是我们根本不知道为什么这样会导致<code>BSOD(Double Free)</code>
      下面是本人关于CVE-2018-8453的分析报告
    </p>
  <p>下面是本人关于 <font color="#FF5370">CVE-2018-8453</font>的分析报告 </p>
    <p>
      触发<font color="#82AAFF">BSOD</font>的Poc中,完成了1 - 5的准备工作之后,便向滚动条子控件发送了一个<code>WM_LBUTTONDOWN</code>消息<br /></p>
      <img src="./img/programs.png"  width="800px"><br /><br />
    <p>我们知道,向滚动条子控件(Scroll)发送<font class="Struct">WM_LBUTTONDOWN</font>,消息时,会调用到<code>win32kfull!xxxSBTrackInit()</code>函数,该函数主要是来实现滚动条跟随鼠标移动的,该函数首先会创建一个0x80字节大小的Session Pool,用来保存 <font class="Struct">tagSBTrack</font>结构
      接着将创建好<font class="Struct">tagSBTRACK</font>结构的指针,写入到 <font class="Struct">tagTHREADINFO.tagSBTRACK</font>处,在Windows10 1703 X64中,该结构的偏移地址为<font class="Struct">tagTHREADINFO+0x278</font></p>
      <img src="./img/scroll.png"  width="800px">
    <p>需要注意的是<code>Lock(&pSBTrack->spwndSBNotify, pwnd->spwndParent)</code>,让滚动条子控件引用父类窗口,也就是我们创建的父窗口建立引用+1,此处很重要(PS:当时写Poc时创建滚动条子控件时,属性忘记设置<font class="Struct">WS_CHILD</font>,导致滚动条窗口的父窗口非创建的父窗口导致无法利用漏洞)</p>
      <img src="./img/fuction.png"  width="800px">
    <p>
    <code>win32kfull!xxxSBTrackInit</code>函数最后会调用<code>win32kfull!xxxSBTrackLoop</code>函数,来进行消息循环,消息循环函数<code>win32kfull!xxxDispatchMessage</code>会使用fnDWORD函数回调R3,这时我们就知道为什么要Hook fnDWORD函数了.
    </p>
    <p>
      在<code>fnDWORD</code>函数里判断是否是滚动条窗口发送的回调,调用<code>DestroyWindow()</code>函数释放主窗口.</p>
      <img src="./img/231.png"  width="400px">
      <p><code>DestoryWindow()</code>函数会调用<code>win32kfull!xxxFreeWindow()</code>函数来释放窗口,但是该函数经常被调用,我们可以使用条件断点来判断是否是我们要释放的窗口
    </p>
    <p>
      <font color="#FFCB6B"> Ba e1 win32kfull!xxxFreeWindow  ".if( poi(rcx) == 释放窗口的句柄 ){}.else{g}"</font>
    </p>
      <img scr="./img/callback.png"  width="800px">
      <p>此时在rcx+0x52处下内存写入断点 rcx+0x52 处为<font class="Struct">tagwnd.FNID</font>,也就是导致漏洞的主角(也不能这样说,本质问题还是Kernel CallBack).窗口扩展空间必须要在创建窗口类时设置窗口类的大小,在Poc中我设置为 <font class="Struct">wndclass.cbWndExtra = 0x8</font></p>
    <p>
      触发<code>xxxClientAllocWindowClassExtraBytes</code>函数回调后,如何判断是主窗口调用的该函数呢,这里我使用了<code>SetWindowLongA(Window, 0, (ULONG)Window);</code>将主窗口句柄保存在窗口扩展中.</p>
      <img src="./img/byteshook.png"  width="800px">
      <p>MSG中,保存了窗口扩展类的地址,里面保存了设置的父窗口指针,通过这个来判断是否为父窗口调用的<code>xxxClientAllocWindowClassExtraBytes</code>函数.</p>
    <p>
      此时,我们创建一个新的滚动条窗口,不设置父类句柄,以及子类属性,并设置正在释放窗口Window的FNID为 0x2A1,本来Window的FNID为0x8000,调用<code>NtUserSetWindowFNID</code>后为0x82A1,接着设置新的捕获窗口.
    </p>
    <p>
      此时父窗口虽然已经调用<code>DestroyWindow</code>释放了,但是由于滚动条子窗口Scroll还对父窗口有引用,所以并未释放,最后<code>win32kfull!xxxSBTrackLoop</code>函数结束后,对<font class="Struct">pSBTrack->spwndSBNotify</font>和链接的主窗口解引用,由于是最后一处引用,调用<code>HMAssignmentUnlock()</code>函数时会判断被绑定(<font class="Struct">Win32 Object</font>)结构的cLockObj结构是否为1,如果为1代表只有一个引用,修改指针内容后后便立刻调用函数释放该结构,此处释放的函数为(<code>Win32kfull!DestoryWindow</code>)</p>
      <img scr="./img/jump.png"  width="800px">
    <p>
      问题就在这里,由于释放窗口要调用<code>win32kfull!xxxFreeWindow</code>函数,而FNID为释放窗口的Flag属性,被修改为0x82A1后,会再次调用<code>fnDWORD</code>函数回调R3,并发送为0x70的Message. </p>
      <img src="./img/1.png"  width="500px">
      <p>判断FNID的内容,来决定是否调用fnDWORD</p>
      <img src="./img/2.png"  width="500px">
      <p>可以看到此处调用fnDWORD,并且发送的Message为0x70</p>
      <img src="./img/3.png"  width="500px">
    <p>此时,我们向新创建的滚动条控件发送<font class="Struct">Message</font>为0x1F的消息,最终会调用到<code>win32kfull!xxxEndScroll</code>函数</p>
    <img src="./img/dropmsg.png"  width="500px">
      <img scr="./img/mgs0x1f.png"  width="800px">
    <p>通过在<code>win32kfull!SetCapture</code>设置的捕获窗口,可绕过其验证,直入到释放<font class="Struct">tagSBTrack结构</font></p>
      <img scr="./img/psbtrack.png"  width="800px">
    <p>此时线程内的<font class="Struct">tagSBTrack</font>结构已经被释放了,接着回到<code>win32kfull!xxxSBTrackInit</code>执行代码</p>
      <img src="./img/sbtrackinit.png"  width="800px">
    <p>因为<font class="Struct">tagSBTrack</font>结构已经在<code>win32kfull!xxxEndScroll</code>函数被释放了,但是<code>win32kfull!xxxSBTrackInit</code>函数并不知道,再次释放该内存导致<font class="Struct">Double Free</font>!</p>
    </p>
    </p>
    <h2 id="Download">附件下载:</h2>

    <p>
      Word:<a href="../images/CVE-2018-8453/CVE-2018-8453_0.doc">CVE-2018-8453从BSOD到ExpLoit(上).doc</a>
    </p>

    <p>
      Poc:<a href="../images/CVE-2018-8453/CVE-2018-8453_Poc.zip">Poc.zip</a>
    </p>

    <h2 id="Time">2020/02/16 20:55</h2>

    <big>
      <a href="../index.html">Return HomePage</a>
    </big>
  </body>
</html>
